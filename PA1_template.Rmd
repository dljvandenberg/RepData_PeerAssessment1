---
title: "Reproducible Research: Activity Monitoring"
output: 
  html_document:
    keep_md: true
---


## Loading and preprocessing the data

Set workdir, unzip data and read csv file to dataframe

```{r}
suppressMessages(library(lubridate))
setwd("~/git/RepData_PeerAssessment1")
unzip("activity.zip")
df.activity <- read.csv("activity.csv")
df.activity$date <- ymd(df.activity$date)
```


## What is mean total number of steps taken per day?

<!--
For this part of the assignment, you can ignore the missing values in the dataset.
1. Calculate the total number of steps taken per day
2. Make a histogram of the total number of steps taken each day
3. Calculate and report the mean and median of the total number of steps taken per day
--> 

```{r}
df.steps.per.day <- aggregate(steps ~ date, data = df.activity, sum)
hist(df.steps.per.day$steps)
mean.steps.per.day <- mean(df.steps.per.day$steps)
median.steps.per.day <- median(df.steps.per.day$steps)
mean.steps.per.day
median.steps.per.day
```


## What is the average daily activity pattern?

1. Make a time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all days (y-axis)
```{r}
df.average.steps.per.interval <- aggregate(steps ~ interval, data = df.activity, mean)
plot(df.average.steps.per.interval, type="l")
```

2. Which 5-minute interval, on average across all the days in the dataset, contains the maximum number of steps?

```{r}
df.average.steps.per.interval$interval[which.max(df.average.steps.per.interval$steps)]
```


## Imputing missing values

Calculate total number of rows with missing values in the dataset:

```{r}
sum(apply(df.activity, 1, function(row) any(is.na(row))))
```

Creating new dataset while imputing missing values by using linear interpolation of closest non-NA rows

```{r}
df.activity.imputed <- df.activity
df.activity.imputed$steps <- approxfun(seq_along(df.activity$steps), df.activity$steps, method="linear", rule=2)(seq_along(df.activity$steps))
if(any(is.na(df.activity.imputed))) {print("WARN: NA values in df.activity.imputed")}
```

Histogram of the total number of steps taken each day after imputation:

```{r}
df.steps.per.day.imputed <- aggregate(steps ~ date, data = df.activity.imputed, sum)
hist(df.steps.per.day.imputed$steps)
```

Mean and median total number of steps taken per day after imputation:

```{r}
mean.steps.per.day.imputed <- mean(df.steps.per.day.imputed$steps)
median.steps.per.day.imputed <- median(df.steps.per.day.imputed$steps)
mean.steps.per.day.imputed
median.steps.per.day.imputed
```

Recall the non-imputed versions of these metrics:

```{r}
mean.steps.per.day
median.steps.per.day
```

We conclude that linear imputation of missing data changes the mean value of total steps per day by `r round(mean.steps.per.day.imputed-mean.steps.per.day, 2)` and the median by `r median.steps.per.day.imputed-median.steps.per.day`.


## Are there differences in activity patterns between weekdays and weekends?

Create a new factor variable in the dataset with two levels – “weekday” and “weekend” indicating whether a given date is a weekday or weekend day.

```{r}
weekorweekend <- function(date) {
    if (weekdays(date) %in% c("Saturday", "Sunday")) {"weekend"} else {"weekday"}
}
df.activity.imputed$weekorweekend <- as.factor(sapply(df.activity.imputed$date, weekorweekend))
```

Make a panel plot containing a time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all weekday days or weekend days (y-axis). See the README file in the GitHub repository to see an example of what this plot should look like using simulated data.

```{r}
df.average.steps.per.interval.and.weekorweekday.imputed <- aggregate(steps ~ interval + weekorweekend, data = df.activity.imputed, mean)
suppressMessages(library(ggplot2))
ggplot(data = df.average.steps.per.interval.and.weekorweekday.imputed, aes(x=interval, y=steps)) + facet_grid(weekorweekend ~ .) + geom_line()
```

